#include <LedControl.h>
#include <EEPROM.h>

#define DEBUG

// 8x8点阵屏引脚配置 (DIN, CLK, CS, 数量)
LedControl lc = LedControl(12, 11, 10, 1);

// 霍尔传感器引脚
#define HALL_SENSOR1 A0
#define HALL_SENSOR2 A1

// 模式切换按钮
#define MODE_BUTTON 2

unsigned char font[38][8] = {
  { 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C },  //0
  { 0x08, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E },  //1
  { 0x7E, 0x2, 0x2, 0x7E, 0x40, 0x40, 0x40, 0x7E },    //2
  { 0x3E, 0x2, 0x2, 0x3E, 0x2, 0x2, 0x3E, 0x0 },       //3
  { 0x8, 0x18, 0x28, 0x48, 0xFE, 0x8, 0x8, 0x8 },      //4
  { 0x3C, 0x20, 0x20, 0x3C, 0x4, 0x4, 0x3C, 0x0 },     //5
  { 0x3C, 0x20, 0x20, 0x3C, 0x24, 0x24, 0x3C, 0x0 },   //6
  { 0x3E, 0x22, 0x4, 0x8, 0x8, 0x8, 0x8, 0x8 },        //7
  { 0x0, 0x3E, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3E },   //8
  { 0x3E, 0x22, 0x22, 0x3E, 0x2, 0x2, 0x2, 0x3E },     //9
  { 0x8, 0x14, 0x22, 0x3E, 0x22, 0x22, 0x22, 0x22 },   //A
  { 0x3C, 0x22, 0x22, 0x3E, 0x22, 0x22, 0x3C, 0x0 },   //B
  { 0x3C, 0x40, 0x40, 0x40, 0x40, 0x40, 0x3C, 0x0 },   //C
  { 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x0 },   //D
  { 0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x7C },  //E
  { 0x7C, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40 },  //F
  { 0x3C, 0x40, 0x40, 0x40, 0x40, 0x44, 0x44, 0x3C },  //G
  { 0x44, 0x44, 0x44, 0x7C, 0x44, 0x44, 0x44, 0x44 },  //H
  { 0x7C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x7C },  //I
  { 0x3C, 0x8, 0x8, 0x8, 0x8, 0x8, 0x48, 0x30 },       //J
  { 0x0, 0x24, 0x28, 0x30, 0x20, 0x30, 0x28, 0x24 },   //K
  { 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7C },  //L
  { 0x81, 0xC3, 0xA5, 0x99, 0x81, 0x81, 0x81, 0x81 },  //M
  { 0x0, 0x42, 0x62, 0x52, 0x4A, 0x46, 0x42, 0x0 },    //N
  { 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C },  //O
  { 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x20, 0x20, 0x20 },  //P
  { 0x1C, 0x22, 0x22, 0x22, 0x22, 0x26, 0x22, 0x1D },  //Q
  { 0x3C, 0x22, 0x22, 0x22, 0x3C, 0x24, 0x22, 0x21 },  //R
  { 0x0, 0x1E, 0x20, 0x20, 0x3E, 0x2, 0x2, 0x3C },     //S
  { 0x0, 0x3E, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8 },         //T
  { 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x22, 0x1C },  //U
  { 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x18 },  //V
  { 0x0, 0x49, 0x49, 0x49, 0x49, 0x2A, 0x1C, 0x0 },    //W
  { 0x0, 0x41, 0x22, 0x14, 0x8, 0x14, 0x22, 0x41 },    //X
  { 0x41, 0x22, 0x14, 0x8, 0x8, 0x8, 0x8, 0x8 },       //Y
  { 0x0, 0x7F, 0x2, 0x4, 0x8, 0x10, 0x20, 0x7F },      //Z
  { 0x8, 0x7F, 0x49, 0x49, 0x7F, 0x8, 0x8, 0x8 },      //中
  { 0xFE, 0xBA, 0x92, 0xBA, 0x92, 0x9A, 0xBA, 0xFE },  //国
};

unsigned char font2[][8] = {
  { 0x00, 0x3c, 0x66, 0x76, 0x6e, 0x66, 0x66, 0x3c },  // 0
  { 0x00, 0x18, 0x18, 0x1c, 0x18, 0x18, 0x18, 0x7e },  // 1
  { 0x00, 0x3c, 0x66, 0x60, 0x30, 0x0c, 0x06, 0x7e },  // 2
  { 0x00, 0x3c, 0x66, 0x60, 0x38, 0x60, 0x66, 0x3c },  // 3
  { 0x00, 0x30, 0x38, 0x34, 0x32, 0x7e, 0x30, 0x30 },  // 4 30307e3234383000
  { 0x00, 0x7e, 0x06, 0x06, 0x3e, 0x60, 0x66, 0x3c },
  { 0x00, 0x3c, 0x66, 0x06, 0x3e, 0x66, 0x66, 0x3c },
  { 0x00, 0x7e, 0x66, 0x66, 0x30, 0x30, 0x18, 0x18 },
  { 0x00, 0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c },
  { 0x00, 0x3c, 0x66, 0x66, 0x7c, 0x60, 0x66, 0x3c },  // 9
  { 0x00, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66 },  // A
  { 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x66, 0x66, 0x3e },  // B
  { 0x00, 0x3c, 0x66, 0x06, 0x06, 0x06, 0x66, 0x3c },  // C
  { 0x00, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3e },  // D
  { 0x00, 0x7e, 0x06, 0x06, 0x3e, 0x06, 0x06, 0x7e },  // E
  { 0x00, 0x7e, 0x06, 0x06, 0x3e, 0x06, 0x06, 0x06 },  // F 0606063e06067e00
  { 0x00, 0x3c, 0x66, 0x06, 0x06, 0x76, 0x66, 0x3c },  // G
  { 0x00, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66 },  // H
  { 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c },  // I
  { 0x00, 0x78, 0x30, 0x30, 0x30, 0x36, 0x36, 0x1c },  // J
  { 0x00, 0x66, 0x36, 0x1e, 0x0e, 0x1e, 0x36, 0x66 },  // K
  { 0x00, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x7e },  // L
  { 0x00, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6 },  // M
  { 0x00, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0xc6, 0xc6 },  // N
  { 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c },  // O
  { 0x00, 0x3e, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x06 },  // P
  { 0x00, 0x3c, 0x66, 0x66, 0x66, 0x76, 0x3c, 0x60 },  // Q
  { 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x1e, 0x36, 0x66 },  // R
  { 0x00, 0x3c, 0x66, 0x06, 0x3c, 0x60, 0x66, 0x3c },  // S
  { 0x00, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18 },  // T
  { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c },  // U
  { 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18 },  // V
  { 0x00, 0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6 },  // W
  { 0x00, 0xc6, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0xc6 },  // X
  { 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18 },  // Y
  { 0x00, 0x7e, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x7e }   // Z
};

/*
// 定义可读的图案创建宏
#define PATTERN(a, b, c, d, e, f, g, h) ((uint64_t)a << 56) | ((uint64_t)b << 48) | ((uint64_t)c << 40) | ((uint64_t)d << 32) | ((uint64_t)e << 24) | ((uint64_t)f << 16) | ((uint64_t)g << 8) | (uint64_t)h

const uint64_t PROGMEM IMAGES[] = {
  PATTERN(0x7E, 0x18, 0x18, 0x18, 0x1C, 0x18, 0x18, 0x18),  // 0
  PATTERN(0x7E, 0x06, 0x0C, 0x30, 0x60, 0x66, 0x3C, 0x00)   // 1
  // ...
};
*/
const uint64_t PROGMEM IMAGES1[] = {
  0x3c66666e76663c00,  // 0
  0x7e1818181c181800,  // 1
  0x7e060c3060663c00,  // 2
  0x3c66603860663c00,  // 3
  0x30307e3234383000,  // 4
  0x3c6660603e067e00,  // 5
  0x3c66663e06663c00,  // 6
  0x1818183030667e00,  // 7
  0x3c66663c66663c00,  // 8
  0x3c66607c66663c00,  // 9
  0x6666667e66663c00,  // A
  0x3e66663e66663e00,  // B
  0x3c66060606663c00,  // C
  0x3e66666666663e00,  // D
  0x7e06063e06067e00,  // E
  0x0606063e06067e00,  // F
  0x3c66760606663c00,
  0x6666667e66666600,
  0x3c18181818183c00,
  0x1c36363030307800,
  0x66361e0e1e366600,
  0x7e06060606060600,
  0xc6c6c6d6feeec600,
  0xc6c6e6f6decec600,
  0x3c66666666663c00,
  0x06063e6666663e00,
  0x603c766666663c00,
  0x66361e3e66663e00,
  0x3c66603c06663c00,
  0x18181818185a7e00,
  0x7c66666666666600,
  0x183c666666666600,
  0xc6eefed6c6c6c600,
  0xc6c66c386cc6c600,
  0x1818183c66666600,
  0x7e060c1830607e00,  // Z
};


// 要校准的字符索引 (R, N, 1-7)
const char chars[] = { 'R', 'N', '1', '2', '3', '4', '5', '6', '7' };
const int calibrationChars[] = { 27, 23, 1, 2, 3, 4, 5, 6, 7 };
const int numChars = sizeof(calibrationChars) / sizeof(calibrationChars[0]);

// 存储霍尔值的数据结构
struct HallData {
  int hall1;
  int hall2;
};

HallData savedValues[numChars];  // 存储的校准值
bool isSetupMode = false;        // 当前模式标志

void setup() {

#ifdef DEBUG

  Serial.begin(9600);

#endif

  // 初始化硬件
  pinMode(MODE_BUTTON, INPUT_PULLUP);
  pinMode(HALL_SENSOR1, INPUT);
  pinMode(HALL_SENSOR2, INPUT);

  // 初始化点阵屏
  lc.shutdown(0, false);
  lc.setIntensity(0, 8);
  lc.clearDisplay(0);

  // 检查模式按钮
  if (digitalRead(MODE_BUTTON) == LOW) {
    isSetupMode = true;
    runSetupMode();
  } else {
    loadCalibrationData();
    isSetupMode = false;
  }
}

void loop() {

  // runTestMode();
  // return;

  if (!isSetupMode) {
    runNormalMode();
  }
}

// ==== 测试代码

void runTestMode() {
  for (int j = 0; j < 36; j++) {
    displayChar(j);
    delay(1000);
  }
}

// ====== 设置模式 ======
void runSetupMode() {
  for (int i = 0; i < numChars; i++) {
    // 显示当前字符
    displayChar(calibrationChars[i]);

    // 采集霍尔值 (2秒内多次采样取平均)
    long sum1 = 0, sum2 = 0;
    int samples = 0;
    unsigned long startTime = millis();

    while (millis() - startTime < 2000) {
      sum1 += analogRead(HALL_SENSOR1);
      sum2 += analogRead(HALL_SENSOR2);
      samples++;
      delay(10);
    }

    // 保存平均值
    savedValues[i].hall1 = sum1 / samples;
    savedValues[i].hall2 = sum2 / samples;

    Serial.print("i: ");
    Serial.print(i);
    Serial.print(", hall1: ");
    Serial.print(savedValues[i].hall1);
    Serial.print(", hall2: ");
    Serial.println(savedValues[i].hall2);
  }

  // 保存数据到EEPROM
  saveCalibrationData();

  // 设置完成提示
  for (int i = 0; i < 3; i++) {
    lc.clearDisplay(0);
    delay(200);
    displayChar(8);  // 显示完成符号 (数字8)
    delay(500);
  }

  isSetupMode = false;
}

// ====== 运行模式 ======
void runNormalMode() {
  // 读取霍尔传感器
  int hall1 = analogRead(HALL_SENSOR1);
  int hall2 = analogRead(HALL_SENSOR2);
  // 寻找最匹配的字符
  int bestMatch = findBestMatch(hall1, hall2);

  if (digitalRead(MODE_BUTTON) == LOW) {
    Serial.print("hall1: ");
    Serial.print(hall1);
    Serial.print(", hall2: ");
    Serial.println(hall2);
    Serial.print("match: ");
    Serial.println(chars[bestMatch]);
  }

  // 显示匹配的字符
  if (bestMatch >= 0) {
    displayChar(calibrationChars[bestMatch]);
  }

  delay(500);  // 适当延时减少刷新率
}

// ====== 辅助函数 ======
// 在点阵屏上显示字符
void displayChar(int charIndex) {
  for (int row = 0; row < 8; row++) {
    // 字体从下往上排，我们从下往上读
    byte val = font2[charIndex][row];
    // 显示前反转位顺序
    lc.setRow(0, row, reverseBits(val));
  }
}
byte reverseBits(byte b) {
  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
  return b;
}

void displayImage(int index) {
  uint64_t image = IMAGES1[index];
  for (int i = 0; i < 8; i++) {
    byte row = (image >> i * 8) & 0xFF;
    for (int j = 0; j < 8; j++) {
      lc.setLed(0, i, j, bitRead(row, j));
    }
  }
}

// 寻找最佳匹配的字符
int findBestMatch(int hall1, int hall2) {
  int bestIndex = -1;
  int minDiff = 10000;  // 初始设置为大数

  for (int i = 0; i < numChars; i++) {
    // 计算差值 (曼哈顿距离)
    int diff = abs(hall1 - savedValues[i].hall1) + abs(hall2 - savedValues[i].hall2);

    if (diff < minDiff) {
      minDiff = diff;
      bestIndex = i;
    }
  }

  return bestIndex;
}

// 保存校准数据到EEPROM
void saveCalibrationData() {
  int addr = 0;
  for (int i = 0; i < numChars; i++) {
    EEPROM.put(addr, savedValues[i]);
    addr += sizeof(HallData);
  }
}

// 从EEPROM加载校准数据
void loadCalibrationData() {
  int addr = 0;
  for (int i = 0; i < numChars; i++) {
    EEPROM.get(addr, savedValues[i]);
    addr += sizeof(HallData);

    Serial.print("i: ");
    Serial.print(i);
    Serial.print(", hall1: ");
    Serial.print(savedValues[i].hall1);
    Serial.print(", hall2: ");
    Serial.println(savedValues[i].hall2);
  }
}